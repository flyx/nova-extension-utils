# Documentation

First of all, you'll need the [Nix package manager][1] installed.
Then, you need to enable Nix Flakes, [see here][2].
Lastly you'll need the [XCode command line tools][3] – the compilers available via Nix aren't able to generate universal binaries, so we'll use what Apple provides.

When you have all that, create a new directory, and run

    nix flake init github:flyx/nova-extension-utils

The most important file that will be created is `flake.nix`, which uses the Nix syntax.
You don't need to be an expert in Nix to create simple extensions, but mind that it isn't simply JSON.

## External Inputs

If there is an existing TreeSitter grammar you want to use, you can reference it in your `flake.nix`.
The template already contains this input:

```nix
tree-sitter-nix = {
  url = "github:cstrahan/tree-sitter-nix";
  flake = false;
}; 
```

This is an example and references the TreeSitter grammar for Nix.
You'll want to change that to whatever grammar you want to use.

`flake = false;` tells Nix that the referenced repository is not a Nix Flake.
This will make Nix just download the repository's contents.

When building for the first time, Nix will create a `flake.lock` file that remembers the revision you downloaded.
To update to a newer revision, you can do

    nix flake lock --update-input tree-sitter-nix

This also applies to the other inputs, one being `nova-utils`.

## What is Provided by this Flake

`nova-extension-utils` provides an *overlay* on `nixpkgs` that defines two functions:

 * `pkgs.buildNovaTreeSitterLib` builds a `.so` file from your grammar.
   It should work out-of-the-box for grammars with standard repository layout.
 * `pkgs.buildNovaExtension` builds a Nova extension.
   This function has a lot of options and will be our main concern.
   Everything else provided by `nova-extension-utils` will be injected into an extension built with this function.

If you don't know how overlays work, just leave the code from the template that gives you `pkgs`.
For simple usage, you really only need to modify the arguments given to these two functions.

## Basic Metadata

A Nova extension contains an `extension.json` that will define the extension's metadata (see [Nova docs][4]).
`buildNovaExtension` autogenerates this file from the arguments you provide.
Required are only the following:

 * `pname`: The name of your extension. A name of `Foo` will generate `Foo.novaextension`.
   Corresponds to the `name` in the manifest (`pname` is a Nix convention).
 * `src` are the sources from which the extension should be generated.
   Usually this is `self`, which points to the content of your Flake.
 * `identifier` is the unique identifier as required by the manifest.
   This will also be used as base for the keys of all configuration items.
 * The items `version`, `organization`, `description`, `categories` and `license` as required by the manifest.
 
Optionally, you can set `treeSitterLibs` to the list of syntaxes you want to use.
Each syntax must have been created via `buildNovaTreeSitterLib`.

You can also provide other items allowed in the manifest, those will be piped through to `extension.json`.
The only special cases are `config` and `configWorkspace`, which are processed by `nova-extension-utils`.

## Supporting TreeSitter Grammars

Sadly, you can't simply drop the TreeSitter grammar into Nova and call it a day.
You'll need an `.xml` file in `Syntaxes` that defines your syntaxes' metadata ([see docs][6]).
A `<tree-sitter>` element there enables the usage of your compiled TreeSitter grammar.

On itself, this won't do anything.
You also need to define queries for the tree generated by the grammar.
The most common query file is `highlights.scm` for syntax highlighting.
You probably also want `folds.scm` for code folding.
Refer to the [TreeSitter docs][7] and the [Nova docs][8] for details on writing queries.

Existing TreeSitter grammars may provide these files, but they are not directly usable with Nova, because they use different attribute captures and predicates.
The best way to overcome this is to copy the provided files into `Queries` and make adjustments there.

If you have a `Queries` folder, or any other folder typically used for Nova extensions (`Syntaxes`, `Scripts`, …) in your repository, `buildNovaExtension` will automatically copy it into the extension it generates.

## Configuration

`nova-extension-utils` assumes that the user might want to override any global configuration option your extension provides per workspace.
Therefore, for every global configuration option you define, a workspace configuration option is automatically defined as optional value that overrides the global value, if set.

Instead of defining a full `key` for every option, you give an attrSet where the name of an option gets appended to the `identifier` to define the key.
So, if for example your identifier is `org.example`, this input:

```nix
config = {
  languageServer = {
    title   = "Language Server";
    type    = "path";
    default = "nil";
  };
};
```

will become this part of the manifest:

```json
"config": [
  {
    "key": "org.example.languageServer",
    "title": "Language Server",
    "default": "nil" 
  }
],
"workspaceConfig": [
  {
    "key": "org.example.languageServer",
    "title": "Language Server",
    "required": false
  }
]
```

The `default` value will not be put in the workspace config, which will instead have `required` set to `false` so that it only overrides when the user sets a value.

The workspace overriding is implemented in a `config.js` file that will be generated from your `config` argument.
In your `main.js`, you use it like this:

```javascript
const Config = require("config.js").Config;
let config = new Config();
config.languageServer.value(); // retrieve the current value
```

Besides `value()`, each config item also implements `onDidChange(callback, thisValue)` and `observe(callback, thisValue)` corresponding to the [Configuration methods in the Nova API][5].

## Language Server

`nova-extension-utils` provides a class `LanguageServer` that lets you define a simple language server.
It is not very customizable and probably is not the right tool for more complex scenarios, but if all you have is an existing language server and the need to use it in nova, this is the tool for you.

You use it like this:

```javascript
const LanguageServer = require("language-server.js").LanguageServer;
let langserver = new LanguageServer(
  // internal identifier. the client will have the id org.example.myLanguage.client
  "org.example.myLanguage",
  // serverOptions as defined in the docs for LanguageClient
  { syntaxes: ["myLanguage"] },
  config.languageServer
);
```

The language server expects the path to the executable as config item.
This way, the user can set a global default and override it if necessary per workspace.

The language server starts automatically and will restart when the configuration value changes.

## Formatter

The class `Formatter` lets you define a command for formatting your code, using an external utility:

```javascript
const Formatter = require("fomatter.js").Formatter;
let formatter = new Formatter(
  // identifier used for the formatter (to invoke it explicitly from the menu)
  "org.example.myFormatter",
  // can be a string or a ConfigItem that defines the path of the
  // external utility doing the formatting. Typically this would be the name of
  // the executable, whose absolute path will be queried from the PATH env variable.
  config.formatterPath,
  // arguments to the utility. These must configure the utility to take input
  // from stdin and write output to stdout. May be a ConfigItem.
  [ "fmt", "--stdio" ],
  // syntaxes this formatter handles.
  [ "myLanguage" ],
  // ConfigItem that specifies whether documents are auto-formatted before saving.
  // The formatter will listen to changes of the ConfigItem and react accordingly.
  // may be null or undefined to disable automatic formatting.
  config.formatOnSave
)
```

`Formatter` is a `Disposable` that can be registered to `nova.subscriptions`.

## Readme

A Nova extension must provide a Readme file.
That file is user-facing and displayed in the Nova extension library when you publish your extension.
You might also want to have a developer Readme file that describes how to contribute to your extension.

Therefore, `buildNovaExtension` will search for a file `Readme-user.md` and copy that into your extension.
Only if such a file does not exist will it take a `Readme.md` instead.

## Building and Testing

The command to build your extension is

    nix build --impure

We use `--impure` to have access to the Xcode-provided clang.
A standard Nix macOS installation uses `--impure` by default but if you have configured it differently, you need to give this option.

Afterwards, you should have a `result` symlink containing a folder `<name>.novaextension`.
Open this folder in a new window to test the extension.
In the new window, select `Extensions->Activate Project as Extension` from the menu.

Rebuilding the extension after modification will create a *different* folder, not update the previous one.
This is how Nix works.
To test the new version, deactivate the previous version, close that window, then open the new folder.
Nova might not update the `result` symlink on `nix build` so I usually issue a `rm result` first.


 [1]: https://nixos.org/download.html
 [2]: https://nixos.wiki/wiki/Flakes
 [3]: https://developer.apple.com/library/archive/technotes/tn2339/_index.html
 [4]: https://docs.nova.app/extensions/manifest/
 [5]: https://docs.nova.app/api-reference/configuration/
 [6]: https://docs.nova.app/syntax-reference/syntaxes/
 [7]: https://tree-sitter.github.io/tree-sitter/using-parsers#pattern-matching-with-queries
 [8]: https://docs.nova.app/syntax-reference/tree-sitter/#queries